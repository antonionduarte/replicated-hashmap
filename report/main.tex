\documentclass[sigconf]{acmart}

\usepackage{multirow}
\usepackage{graphicx}
\usepackage[ruled, vlined]{algorithm2e}
% \usepackage{algorithm}
% \usepackage{algpseudocode}

\graphicspath{ {images/} }

\SetKwBlock{Interface}{Interface:}{}
\SetKwBlock{State}{State:}{}
\SetKwBlock{Requests}{Requests:}{}
\SetKwBlock{Indications}{Indications:}{}

\SetKwProg{UponTimer}{Upon Timer}{ do:}{}
\SetKwProg{Procedure}{Procedure}{ do:}{}
\SetKwProg{Upon}{Upon}{ do:}{}
\SetKwProg{If}{If}{ do:}{}
\SetKwProg{Foreach}{Foreach}{ do:}{}

\SetKwComment{Comment}{/* }{ */}
\SetKw{Trigger}{Trigger}
\SetKw{Call}{Call}
\SetKw{CancelTimer}{Cancel Timer}
\SetKw{SetupTimer}{Setup Timer}
\SetKw{SetupPeriodicTimer}{Setup Periodic Timer}

%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2022}
\acmYear{2022}
%\acmDOI{10.1145/1122445.1122456}

%% These commands are for a PROCEEDINGS abstract or paper.
\acmConference[ASD22/23]{The first project delivery of ASD2223}{2022}{Faculdade de Ciências e Tecnologia, NOVA University of Lisbon, Portugal}
\acmBooktitle{The Projects of ASD - first delivery, 2021, Faculdade de Ciências e Tecnologia, NOVA University of Lisbon, Portugal}
%\acmPrice{15.00}
%\acmISBN{978-1-4503-XXXX-X/18/06}


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Strongly Consistent Replicated HashMap}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{António Duarte}
\authornote{Student number 58278. %responsibility?
}
\email{an.duarte@campus.fct.unl.pt}
\affiliation{%
    \institution{MIEI, DI, FCT, UNL}
}

\author{Diogo Almeida}
\authornote{Student number 58369. %responsibility?
}
\email{daro.almeida@campus.fct.unl.pt}
\affiliation{%
    \institution{MIEI, DI, FCT, UNL}
}

\author{Diogo Fona}
\authornote{Student number 57940. %responsibility?
}
\email{d.fona@campus.fct.unl.pt}
\affiliation{%
    \institution{MIEI, DI, FCT, UNL}
}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
\renewcommand{\shortauthors}{Duarte, Almeida, and Fona.}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
Strong consistency in replicated hash maps refers to the property of the data being kept in sync across all of the replicas in the system. This means that, at any given time, all of the replicas will have the same set of key-value pairs, and any changes made to the data on one replica will be immediately reflected on all of the other replicas.

Agreement protocols like Paxos are used to ensure that the replicas in a distributed system can come to consensus on the state of the data, even in the presence of failures. This is important for maintaining strong consistency in replicated hash maps, as it ensures that the replicas are all in agreement on the state of the data and can continue to operate correctly.

In this work we propose a replicated hash map which uses an agreement protocol to maintain strong consistency between the replicas of the system. We further conduct an experimental evaluation where the system is tested with increasing loads of operation requests by clients. 

\end{abstract}

%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}

A replicated hash map is a distributed data structure that allows for efficient access to data across a network of machines. It uses the concept of a hash map, which is a data structure that stores key-value pairs and allows for efficient lookup of values based on their associated keys. In a replicated hash map, multiple copies of the hash map are maintained on different machines in the network, and agreement protocols can be used to ensure that all copies are kept consistent with each other.

Paxos \cite{leslie1998part} \cite{lamport2001paxos} \cite{van2015paxos} and Multi-Paxos \cite{lamport2001paxos} \cite{du2009multi} \cite{van2015paxos} are examples of agreement protocols that are commonly used in distributed systems to achieve consistency in replicated data structures. The Paxos algorithm is a method for reaching consensus among a group of nodes in a distributed system. Multi-Paxos is a variant of the Paxos algorithm that allows for improved performance in scenarios where there are multiple replicated data structures, or multiple instances of the Paxos algorithm running concurrently.

In both Paxos and Multi-Paxos, nodes in the distributed system communicate with each other using a series of rounds, during which they propose values, vote on the proposed values, and ultimately agree on a single value to be chosen. Once consensus has been reached, the agreed-upon value can be safely used by the nodes in the system, ensuring that all copies of the replicated data are consistent with each other.

Operations decided with agreement have to be executed in the same order in every replica so they don't diverge their state. State machine replication is a technique used in distributed systems to ensure that the same sequence of operations is performed on all replicas of a given state machine. This is typically achieved through the use of an agreement protocol, which is used to coordinate the actions of the replicas and reach consensus on the order in which operations should be applied.

In this work, we present a proposal for a replicated hash map application that takes use of an agreement protocol, either Paxos or Multi-Paxos, and state machine replication implemented with the Babel \cite{fouto2022babel} Java framework.

The remainder of this article is organized as follows: In Section 2 we will be going over the Related Work, explaining more thoroughly the mentioned protocols; In Section 3 we will go over the details of our implementation of the protocols and how they interact with each other; In Section 4 we present the results of our experimental evaluation, testing the system with an increasing throughput of clients issuing operations. In Section 5 we will summarize and take conclusions on this work.


\section{Related Work}

\subsection{Consensus}

The consensus problem in a distributed system refers to the challenge of achieving agreement among a group of processes or nodes, on a single data value. This problem is crucial in distributed systems, as it allows a network of nodes to reach a consistent state.

\begin{itemize}
    \item \textbf{Termination} Every correct process eventually decides a value.
    \item \textbf{Validity} If a process decides on a value \textit{v}, then \textit{v} was proposed by some process.
    \item \textbf{Integrity} No process decides twice.
    \item \textbf{Uniform Agreement} No two processes decide differently. 
\end{itemize}

% TODO: Cite FLP here.
Consensus, as specified in it's formal definition, has been proven to be impossible under an asynchronous system with the crash-fault model, it is, although, possible to achieve a practically useful version by relaxing some of its properties.

\subsection{Paxos} 

Paxos is a distributed agreement protocol that achieves an altered version of Consensus in which we relax the Termination property, ensuring that the system only progresses if it behaves in a synchronous way for a long enough period.

In Paxos, for ease of understanding, \textbf{each replica} is often subdivided into three different components, each with different responsibilities:

\begin{itemize}
    \item \textbf{Proposers}, responsible for proposing new values for the system to decide on.
    \item \textbf{Acceptors}, they promise on proposed values, and lock-in values by accepting them.
    \item \textbf{Learners}, they are the component responsible for understanding that a value has been decided on. 
\end{itemize}

There are three main phases in the Paxos protocol: the prepare phase, the accept phase, and the decide phase. In the prepare phase, the proposers propose on values and asks all the acceptors to promise not to accept any other proposals in future rounds. In the accept phase, replicas asks the other replicas to accept the proposal. If a majority of the replicas accept the proposal, then the round is considered successful and the value is committed in the decide phase.

One of the key benefits of Paxos is that it is able to tolerate failures. For example, if a replica fails during the prepare phase its prepare will be overwritten by a future one, and if a replica fails during the accept phase the other replicas can still come to agreement on the value without it, as it requires a majority quorum to decide. This makes Paxos a robust and fault-tolerant protocol for achieving consensus in distributed systems.

The main disadvantage of using Paxos in opposition to some of its alternatives, is that for each value that we're deciding on, we need to use a new instance of the Protocol. This implies that everytime we want to make a decision, we need to redo all the phases of the algorithm, including the prepare phase, which severely hurts the performance of the protocol. 

\subsection{Multi-Paxos}

Multi-Paxos is a variant of the Paxos protocol that is used when there are multiple replicas that need to agree on multiple values. This can be useful in situations where there are multiple sources of data that need to be kept in sync across the replicas.

Multi-Paxos is a variant of the Paxos protocol and as such, it also uses a series of rounds, or phases, in which the replicas communicate with each other to come to agreement on values. The distinction here is that we select a distinguished proposer (also referred to as leader, in the literature) to be the only one proposing values.

In this protocol, in contrary to Paxos, there is a single instance of the protocol, that contains shared state for decisions made for multiple values. This shared state most importantly contains the distinguished proposer. The usage of this distinguished proposer, allows us to remove the Prepare phase of the protocol when making multiple decisions, therefore using only accept messages sent by the leader and removing one round-trip-time from the process of making a decision.

The leader is elected by using a Prepare phase, either when first initializing the system, or when a process suspects that the current leader has crashed.

\section{Implementation}

% I kept this pseudocode example here.
% \begin{algorithm}
%     % TODO: Write the Pseudocode to how the PubSub interacts with PlumTree
%     \Interface{
%         \Requests{
%             Subscribe(topic)\;
%             Unsubscribe(topic)\;
%             Publish(msg, topic)\;
%         }

%         \Indications{
%             PubsubDeliver(msg)\;
%             SubscriptionReply(topic)\;
%             UnsubscriptionReply(topic)\;
%         }
%     }

%     \texttt{\\}

%     \State{
%         $seenMessages$\;
%         $subscribedTopics$\;
%     }

%     \texttt{\\}

% 		\Upon{Init}{
% 			$seenMessages \leftarrow \{\}$\;
% 			$subscribedTopics \leftarrow \{\}$\; 
% 		}

% 		\texttt{\\}

%     \Upon{PlumtreeDeliver(sender, \{\textbf{GOSSIP}, msg, topic)\}} {
%         \If{$topic \in subscribedTopics \land msg \notin seenMessages$} {
%             $seenMessages \leftarrow seenMessages \cup \{message\}$\;
%             \Trigger PubsubDeliver(msg)\;
%         }
%     }

%     \texttt{\\}

%     \Upon{Subscribe(topic)} {
%         $subscribedTopics \leftarrow subscribedTopics \cup \{topic\}$\;
%         \Trigger{SubscriptionReply(topic)}\;
%     }

%     \texttt{\\}

%     \Upon{Unsubscribe(topic)} {
%         $subscribedTopics \leftarrow subscribedTopics \setminus \{topic\}$\;
%         \Trigger{UnsubscriptionReply(topic)}\;
%     }

%     \texttt{\\}

%     \Upon{Publish(\{message, topic\})} {
%         \Trigger PlumtreeBroadcast(\{message, topic\})\;
        
%         \If{$topic \in subscribedTopics$} {
%             \Trigger PubsubDeliver(msg)\;
%         }
%     }
%     \caption{Unstructured Publish-Subscribe}
% 		\label{alg:uns_pubsub}
% \end{algorithm}

We implemented Paxos, Multi-Paxos and the state machine replication protocol using the Babel Java framework, ensuring both agreement protocols are compared fairly.

\subsection{State Machine Replication}

% Explain HashApp <-> SMR and SMR <-> Agreement and how different operations are run in Paxos 
% don't think we need pseudo-code but wtv

HashApp:
1.1 HashApp receives requests from clients.
    Requests can be one of Get(Key) or Put(Key, Value)
1.2 Each request is assigned a random UUID and this UUID is associated to the client so we know who to respond to later.
1.3 For each request, a notification is sent to the StateMachine to order the request.
StateMachine:
2.1 Upon receiving an order request, the state machine will either buffer it, if it is not currently in the membership or add it to a batch.
    If the state machine is already in the progress of building a batch then this request is simply added to it.
    Otherwise a new batch is created and a timer is started. The batch will be built after the timer expires or a maximum batch size is reached.
2.2 After building a batch, which is a type of command, this command is sent to the agreement protocol where it will eventually be ordered.
2.3 After receiving an ordered command from the agreement protocol, the state machine will execute it if possible.
    If this command is a batch then for each individual request the application is notified that the request was ordered using its UUID.
HashApp:
3.1 After receing an ordered request, the application will execute it and check if there are any clients associated the UUID.
    For every client associated a response is sent.

\subsubsection{Multi-Paxos Leadership} % maybe another name

% Explain how SMR handles leadership from Multi-Paxos 

When using multi paxos as the agreement protocol then one of the replicas is considered the leader.
The leader is responsible for ordering the messages and all followers will forward commands to the leader
instead of the agreement protocol.
A replica will attempt to take leadership in the following circumstances:
1. There is not leader and the replica has a command it needs to order.
2. There is a leader but it hasn't heard from it in a while.
3. There is a leader and the connection to the leader is lost.
4. The replica lost some commands is is unable to execute the new commands
    because they depend on the new ones. The replica only considers commands
    to be lost if it is missing them for a certain amount of time.

The agreement protocol in each statemachine will notify the statemachine about a new leader
when it accepts a Prepare request from another replica.

When a leader change is detected, a replica will resent all pending commands to the new leader.


\subsection{Membership Changes}

% Explain how membership changes are handles and executed with agreement

The state machine can handle membership changes by using commands that add and remove members.
To add or remove a member one of this commands is created and ordered uisng the agreement protocol.
The membership change takes place when the commands are eventually executed.

When a statemachine wants to join the membership, it will contact a replica that is already in the membership and ask them to join.
The replica will attempt to order a Join command using the agreement protocol and when it later executes that command it will send
the joining statemachine any information it requires like the current instance in the agreement protocol, the membership at the instance
it joined and the application state.

When a replica detects that another replica is down it will attempt to order a Leave command.
This command is used to remove a replica from the current membership.

% more subsections?

\section{Experimental Evaluation}

\begin{figure}[htp]
    \centering
    \includegraphics[width=8cm]{3R_128B.pdf}
    \caption{Performance for operations with 128 bytes over 3 replicas.}
    \label{fig:3replicas-128}
\end{figure}

\begin{figure}[htp]
    \centering
    \includegraphics[width=8cm]{3R_1024B.pdf}
    \caption{Performance for operations with 1024 bytes over 3 replicas.}
    \label{fig:3replicas-1024}
\end{figure}

\begin{figure}[htp]
    \centering
    \includegraphics[width=8cm]{6R_128B.pdf}
    \caption{Performance for operations with 128 bytes over 6 replicas.}
    \label{fig:6replicas-128}
\end{figure}

\begin{figure}[htp]
    \centering
    \includegraphics[width=8cm]{6R_1024B.pdf}
    \caption{Performance for operations with 1024 bytes over 6 replicas.}
    \label{fig:6replicas-1024}
\end{figure}

\section{Conclusions}

%%
%% The acknowledgments section is defined using the "acks" environment
%% (and NOT an unnumbered section). This ensures the proper
%% identification of the section in the article metadata, and the
%% consistent spelling of the heading.
\begin{acks}
    To João Leitão, for teaching us how to implement protocols and write good reports.
\end{acks}

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{acmart}

\end{document}
\endinput
%%
%% End of file `sample-sigconf.tex'